# Vulnweb Vulnerability Summary

This is a summary of all vulnerabilities that were intentionally built into Vulnweb. It shows the piece of code that causes the vulnerabilities and gives recommandations on how to fix them.

## Cross Site Scripting (XSS)

VueJS usually doesn't parse user input as raw HTML but it does provide the feature v-html which lets you interpret the provided HTML. In this case, I displayed the "text" variable by using v-html which causes the XSS vulnerability:

```html
<p v-html="text" class="card-text" style="white-space: pre-line"></p>
```

This can be fixed by using the standard text interpolation syntax:

```html
<p class="card-text" style="white-space: pre-line">{{ text }}</p>
```

## Insecure Direct Object References (IDOR) / Broken Access Control

Broken Access Control in Java Spring Boot happens, when you forget to secure a route for specific roles. For exampel the /notes/{noteId} doesn't have any logic that checks if the user has sufficient privileges:

```Java
@GetMapping("/notes/{noteId}")
public NoteResponse one(
        @PathVariable @NotNull Integer noteId,
        @CurrentUser User user) {
    return noteService.findOne(noteId);
}
```

Instead, it should use a feature like `@PreAuthorize` to check the users roles:

```Java
@GetMapping("/notes/{noteId}")
@PreAuthorize("hasRole('ROLE_ADMIN') || @noteService.isResourceOwner(#noteId, #user)")
public NoteResponse one(
        @PathVariable @NotNull Integer noteId,
        @CurrentUser User user) {
    return noteService.findOne(noteId);
}
```

As a second countermeasure, you could replace your numeric IDs with UUIDs, which will make it harder to find existing IDs to exploit an IDOR vulnerability.

## Insecure Hashing Algorithms / Weak Passwords

Before implementing password hashes, you should inform yourself, what algorithms are considered secure for password hashing and then use those. In our example we used the insecure algorithm MD5 within Java Spring Boot:

```Java
@Bean
public PasswordEncoder passwordEncoder() {
    return new PasswordEncoder() {
        @Override
        public String encode(CharSequence rawPassword) {
            return DigestUtils.md5Hex(rawPassword.toString());
        }

        @Override
        public boolean matches(CharSequence rawPassword, String encodedPassword) {
            return DigestUtils.md5Hex(rawPassword.toString()).equals(encodedPassword);
        }
    };
}
```

Instead, you should use secure algorithms like bcrypt:

```Java
@Bean
public PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder(10);
}
```

## SQL Injection

Java Spring Boot used with JPA won't be susceptible to SQL Inejction when used with repositories, because it uses prepared statements by default. However, if we write manual SQL queries, SQL injections are still possible:

```Java
List<Note> notes = entityManager.createNativeQuery("SELECT * FROM note WHERE user_id = " + user.getId() + " AND title LIKE '%" + query + "%';", Note.class).getResultList();
```

Instead we should be using repositories like this:

```Java
public interface NoteRepository extends JpaRepository<Note, Integer> {
    List<Note> findByTitleContaining(String query);
}
```

And then use `findByTitleContaining` in our code.

## Missing JWT Validation

When implementing JWT validation, you should always rely on trusted libraries that do the work of decoding and validating tokens for you. You should never manually decode tokens like this:

```Java
String payload = new String(Base64.getUrlDecoder().decode(token.split("\\.")[1]));
Gson gson = new Gson();
return gson.fromJson(payload, JsonObject.class).get("sub").getAsString();
```

Instead you should use libraries like jjwt that validate your token first and then decode it:

```Java
Claims claims = Jwts.parserBuilder().setSigningKey(Keys.hmacShaKeyFor(appConfig.getJwt().getSecretKey().getBytes())).build().parseClaimsJws(token).getBody();
return claims.getSubject();
```